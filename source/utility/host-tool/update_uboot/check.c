/*
************************************************************************************************************************
*                                                         eGON
*                                         the Embedded GO-ON Bootloader System
*
*                             Copyright(C), 2006-2008, SoftWinners Microelectronic Co., Ltd.
*                                                  All Rights Reserved
*
* File Name : check.c
* Author : Gary.Wang
* Version : 1.1.0
*
* Date : 2007.10.12
* Description : This file provides a function to check Boot0 and Boot1.
*
* Others : None at present.
*
* History :
*  <Author>        <time>       <version>      <description>
* Gary.Wang       2007.10.12      1.1.0        build the file
*
************************************************************************************************************************
*/
#include "check.h"
#include "spare_head.h"
#include <string.h>

/********************************************************************************
*函数名称: check_magic
*函数原型: __s32 check_magic( __u32 *mem_base, const char *magic )
*函数功能: 使用“算术和”来校验内存中的一段数据
*入口参数: mem_base       Boot文件在内存中的起始地址
*          magic          Boot的magic
*返 回 值: CHECK_IS_CORRECT      校验正确
*          CHECK_IS_WRONG        校验错误
*备    注:
********************************************************************************/
__s32 check_magic(__u32 *mem_base, const char *magic)
{
    struct spare_boot_ctrl_head  *bfh;
    unsigned char *p;

    bfh = (struct spare_boot_ctrl_head *)mem_base;
    p = bfh->magic;
    if (strcmp((const char *)p, magic))
    {
        return CHECK_IS_WRONG;
    }
    return CHECK_IS_CORRECT;
}

/********************************************************************************
*函数名称: check_sum
*函数原型: __s32 check_sum( __u32 *mem_base, __u32 size, const char *magic )
*函数功能: 使用“算术和”来校验内存中的一段数据
*入口参数: mem_base           待校验的数据在内存中的起始地址（必须是4字节对齐的）
*          size               待校验的数据的个数（以字节为单位，必须是4字节对齐的）
*返 回 值: CHECK_IS_CORRECT   校验正确
*          CHECK_IS_WRONG     校验错误
*备    注:
********************************************************************************/
__s32 check_sum(__u32 *mem_base, __u32 size)
{
    __u32 *buf;
    __u32 count;
    __u32 src_sum;
    __u32 sum;
    struct spare_boot_ctrl_head  *bfh;

    bfh = (struct spare_boot_ctrl_head *)mem_base;
    /* 生成校验和 */
    // 从Boot_file_head中的“check_sum”字段取出校验和
    src_sum = bfh->check_sum;

    // 将STAMP_VALUE写入Boot_file_head中的“check_sum”字段
    bfh->check_sum = STAMP_VALUE;

    // 以 字（4bytes）为单位计数
    count = size >> 2;
    sum = 0;
    buf = (__u32 *)mem_base;

    // 依次累加，求得校验和
    do
    {
        sum += *buf++;
        sum += *buf++;
        sum += *buf++;
        sum += *buf++;
    }
    while ((count -= 4) > (4 - 1));

    while (count-- > 0)
        sum += *buf++;

    // 恢复Boot_file_head中的“check_sum”字段的值
    bfh->check_sum = src_sum;
    if (sum == src_sum)
        return CHECK_IS_CORRECT;
    else
        return CHECK_IS_WRONG;
}

/********************************************************************************
*函数名称: check_file
*函数原型: __s32 check_file( __u32 *mem_base, __u32 size, const char *magic )
*函数功能: 使用“算术和”来校验内存中的一段数据
*入口参数: mem_base       待校验的数据在内存中的起始地址（必须是4字节对齐的）
*          size           待校验的数据的个数（以字节为单位，必须是4字节对齐的）
*          magic          magic number, 待校验文件的标识码
*返 回 值: CHECK_IS_CORRECT       校验正确
*          CHECK_IS_WRONG         校验错误
*备    注:
********************************************************************************/
__s32 check_file(__u32 *mem_base, __u32 size, const char *magic)
{
    if (check_magic(mem_base, magic) == CHECK_IS_CORRECT
            && check_sum(mem_base, size) == CHECK_IS_CORRECT)
        return CHECK_IS_CORRECT;
    else
        return CHECK_IS_WRONG;
}

__s32 gen_check_sum(void *boot_buf)
{
    struct spare_boot_head_t  *head_p;
    __u32 length;
    __u32 *buf;
    __u32 loop;
    __u32 i;
    __u32 sum;

    head_p = (struct spare_boot_head_t *)boot_buf;
    length = head_p->boot_head.length;

    // must 4-byte-aligned
    if ((length & 0x3) != 0)
        return -1;
    buf = (__u32 *)boot_buf;
    head_p->boot_head.check_sum = STAMP_VALUE;
    loop = length >> 2;

    /* 计算当前文件内容的“校验和”*/
    for (i = 0, sum = 0;  i < loop;  i++)
        sum += buf[i];

    /* write back check sum */
    head_p->boot_head.check_sum = sum;

    return 0;
}
